---
layout: default
title: Observations - SideSpins
---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Observations - SideSpins</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f5f5f5;
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem 1rem;
      }

      .header-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 2rem;
      }

      h1 {
        margin: 0;
        color: #333;
      }

      .btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 6px;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.2s;
        text-decoration: none;
        display: inline-block;
      }

      .btn-primary {
        background: #007cba;
        color: white;
      }

      .btn-primary:hover {
        background: #005a87;
      }

      .btn-secondary {
        background: #6c757d;
        color: white;
      }

      .btn-secondary:hover {
        background: #5a6268;
      }

      .btn-danger {
        background: #dc3545;
        color: white;
      }

      .btn-danger:hover {
        background: #c82333;
      }

      .btn-sm {
        padding: 0.5rem 1rem;
        font-size: 0.875rem;
      }

      /* Observations List */
      .observations-list {
        background: white;
        border-radius: 8px;
        padding: 1.5rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 2rem;
      }

      .observation-card {
        border: 1px solid #e1e5e9;
        border-radius: 6px;
        padding: 1rem;
        margin-bottom: 1rem;
        cursor: pointer;
        transition: all 0.2s;
      }

      .observation-card:hover {
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      .observation-card.active {
        border-color: #007cba;
        background: #f8f9fa;
      }

      .observation-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 0.5rem;
      }

      .observation-title {
        font-size: 1.125rem;
        font-weight: 600;
        margin: 0;
      }

      .observation-meta {
        color: #666;
        font-size: 0.875rem;
      }

      .badge {
        display: inline-block;
        padding: 0.25rem 0.75rem;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
      }

      .badge-practice {
        background: #e3f2fd;
        color: #1976d2;
      }

      .badge-match {
        background: #fff3e0;
        color: #f57c00;
      }

      .badge-active {
        background: #e8f5e9;
        color: #388e3c;
      }

      .badge-completed {
        background: #f3e5f5;
        color: #7b1fa2;
      }

      /* Observation Detail View */
      .observation-detail {
        background: white;
        border-radius: 8px;
        padding: 1.5rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: none;
      }

      .observation-detail.active {
        display: block;
      }

      .detail-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid #e1e5e9;
      }

      .detail-actions {
        display: flex;
        gap: 0.5rem;
      }

      /* Video Player */
      .video-section {
        margin-bottom: 2rem;
      }

      video {
        width: 100%;
        max-width: 100%;
        border-radius: 8px;
        background: #000;
      }

      .no-video-message {
        text-align: center;
        padding: 3rem;
        background: #f8f9fa;
        border-radius: 8px;
        color: #666;
      }

      /* Recording Form */
      .recording-form {
        background: #f8f9fa;
        padding: 1.5rem;
        border-radius: 6px;
        margin-top: 1rem;
        display: none;
      }

      .recording-form.active {
        display: block;
      }

      .form-group {
        margin-bottom: 1rem;
      }

      .form-group label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 600;
        color: #333;
      }

      .form-control {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid #e1e5e9;
        border-radius: 6px;
        font-size: 1rem;
      }

      .form-control:focus {
        outline: none;
        border-color: #007cba;
      }

      /* Notes Section */
      .notes-section {
        margin-top: 2rem;
      }

      .notes-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
      }

      .notes-list {
        max-height: 400px;
        overflow-y: auto;
      }

      .note-card {
        border: 1px solid #e1e5e9;
        border-radius: 6px;
        padding: 1rem;
        margin-bottom: 0.75rem;
        transition: all 0.2s;
      }

      .note-card:hover {
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .note-card.clickable {
        cursor: pointer;
      }

      .note-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
      }

      .note-timestamp {
        font-weight: 600;
        color: #007cba;
        cursor: pointer;
      }

      .note-actions {
        display: flex;
        gap: 0.5rem;
      }

      .note-text {
        color: #333;
        margin: 0;
      }

      .note-form {
        background: #f8f9fa;
        padding: 1.5rem;
        border-radius: 6px;
        margin-bottom: 1rem;
      }

      .form-row {
        display: flex;
        gap: 1rem;
      }

      .form-row .form-group {
        flex: 1;
      }

      /* New Observation Form */
      .new-observation-form {
        background: white;
        border-radius: 8px;
        padding: 1.5rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: none;
        margin-bottom: 2rem;
      }

      .new-observation-form.active {
        display: block;
      }

      .timer {
        font-size: 1.5rem;
        font-weight: 600;
        color: #007cba;
        margin: 1rem 0;
        text-align: center;
      }

      /* Loading & Error States */
      .loading {
        text-align: center;
        padding: 2rem;
        color: #666;
      }

      .error-message {
        background: #fee;
        border: 1px solid #fcc;
        color: #c33;
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 1rem;
      }

      .success-message {
        background: #efe;
        border: 1px solid #cfc;
        color: #3c3;
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 1rem;
      }

      /* Responsive */
      @media (max-width: 768px) {
        .header-actions {
          flex-direction: column;
          gap: 1rem;
          align-items: flex-start;
        }

        .form-row {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <div class="header-actions">
        <h1>ðŸ“¹ Observations</h1>
        <button class="btn btn-primary" id="newObservationBtn">
          + New Observation
        </button>
      </div>

      <!-- New Observation Form -->
      <div class="new-observation-form" id="newObservationForm">
        <h2>Create New Observation</h2>
        <form id="createObservationForm">
          <div class="form-group">
            <label for="observationLabel">Type</label>
            <select id="observationLabel" class="form-control" required>
              <option value="practice">Practice</option>
              <option value="match">Match</option>
            </select>
          </div>
          <div class="form-group">
            <label for="observationDescription">Description</label>
            <textarea
              id="observationDescription"
              class="form-control"
              rows="3"
              placeholder="Optional description..."
            ></textarea>
          </div>
          <div class="form-row">
            <button type="submit" class="btn btn-primary">
              Start Observation
            </button>
            <button type="button" class="btn btn-secondary" id="cancelNewBtn">
              Cancel
            </button>
          </div>
        </form>
      </div>

      <!-- Observations List -->
      <div class="observations-list">
        <h2>Recent Observations</h2>
        <div id="observationsList" class="loading">Loading observations...</div>
      </div>

      <!-- Observation Detail -->
      <div class="observation-detail" id="observationDetail">
        <div class="detail-header">
          <div>
            <h2 id="detailTitle">Observation Details</h2>
            <div id="detailMeta" class="observation-meta"></div>
          </div>
          <div class="detail-actions">
            <button class="btn btn-secondary btn-sm" id="attachRecordingBtn">
              Attach Recording
            </button>
            <button class="btn btn-sm" id="toggleStatusBtn">
              Mark Complete
            </button>
            <button class="btn btn-danger btn-sm" id="deleteObservationBtn">
              Delete
            </button>
            <button class="btn btn-secondary btn-sm" id="closeDetailBtn">
              Close
            </button>
          </div>
        </div>

        <!-- Recording Form -->
        <div class="recording-form" id="recordingForm">
          <h3>Attach Video Recording</h3>
          <form id="attachRecordingForm">
            <div class="form-group">
              <label for="containerName">Container Name</label>
              <input
                type="text"
                id="containerName"
                class="form-control"
                value="observations-videos"
                required
              />
            </div>
            <div class="form-group">
              <label for="blobName">Blob Name (filename in container)</label>
              <input
                type="text"
                id="blobName"
                class="form-control"
                placeholder="e.g., practice-2026-01-08.mp4"
                required
              />
            </div>
            <div class="form-group">
              <label for="offsetSeconds"
                >Recording Start Offset (seconds)</label
              >
              <input
                type="number"
                id="offsetSeconds"
                class="form-control"
                value="0"
                min="-3600"
                max="3600"
              />
              <small
                >Use negative if recording started before observation, positive
                if after</small
              >
            </div>
            <div class="form-row">
              <button type="submit" class="btn btn-primary">
                Save Recording
              </button>
              <button
                type="button"
                class="btn btn-secondary"
                id="cancelRecordingBtn"
              >
                Cancel
              </button>
            </div>
          </form>
        </div>

        <!-- Video Player -->
        <div class="video-section">
          <div id="videoPlayer"></div>
        </div>

        <!-- Notes Section -->
        <div class="notes-section">
          <div class="notes-header">
            <h3>Notes</h3>
          </div>

          <!-- Note Form -->
          <div class="note-form">
            <form id="addNoteForm">
              <div class="form-row">
                <div class="form-group">
                  <label for="noteText">Note Text</label>
                  <textarea
                    id="noteText"
                    class="form-control"
                    rows="2"
                    placeholder="Add a note..."
                    required
                  ></textarea>
                </div>
                <div class="form-group" style="max-width: 200px">
                  <label for="noteOffset">Timestamp (seconds)</label>
                  <input
                    type="number"
                    id="noteOffset"
                    class="form-control"
                    placeholder="Optional"
                    min="0"
                  />
                </div>
              </div>
              <button
                type="button"
                class="btn btn-sm btn-secondary"
                id="useCurrentTimeBtn"
              >
                Use Current Video Time
              </button>
              <button type="submit" class="btn btn-primary">Add Note</button>
            </form>
          </div>

          <!-- Notes List -->
          <div class="notes-list" id="notesList">
            <p class="loading">No notes yet.</p>
          </div>
        </div>
      </div>
    </div>

    <script src="/assets/auth.js"></script>
    <script>
      const authManager = new AuthManager();
      let observations = [];
      let currentObservation = null;
      let notes = [];
      let videoElement = null;
      let activeTimer = null;

      // Initialize
      document.addEventListener("DOMContentLoaded", async () => {
        // Check authentication
        const isAuthenticated = await authManager.requireAuth(
          "/login-new.html?redirect=" +
            encodeURIComponent(window.location.pathname)
        );
        if (!isAuthenticated) return;

        // Load observations
        await loadObservations();

        // Event listeners
        document
          .getElementById("newObservationBtn")
          .addEventListener("click", () => {
            document
              .getElementById("newObservationForm")
              .classList.add("active");
          });

        document
          .getElementById("cancelNewBtn")
          .addEventListener("click", () => {
            document
              .getElementById("newObservationForm")
              .classList.remove("active");
            document.getElementById("createObservationForm").reset();
          });

        document
          .getElementById("createObservationForm")
          .addEventListener("submit", handleCreateObservation);
        document
          .getElementById("attachRecordingBtn")
          .addEventListener("click", showRecordingForm);
        document
          .getElementById("cancelRecordingBtn")
          .addEventListener("click", hideRecordingForm);
        document
          .getElementById("attachRecordingForm")
          .addEventListener("submit", handleAttachRecording);
        document
          .getElementById("closeDetailBtn")
          .addEventListener("click", closeDetail);
        document
          .getElementById("deleteObservationBtn")
          .addEventListener("click", handleDeleteObservation);
        document
          .getElementById("toggleStatusBtn")
          .addEventListener("click", handleToggleStatus);
        document
          .getElementById("addNoteForm")
          .addEventListener("submit", handleAddNote);
        document
          .getElementById("useCurrentTimeBtn")
          .addEventListener("click", useCurrentVideoTime);
      });

      // Load all observations
      async function loadObservations() {
        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/GetObservations`,
            { method: "GET" }
          );

          if (!response.ok) throw new Error("Failed to load observations");

          observations = await response.json();
          renderObservationsList();
        } catch (error) {
          console.error("Error loading observations:", error);
          document.getElementById("observationsList").innerHTML =
            '<div class="error-message">Failed to load observations.</div>';
        }
      }

      // Render observations list
      function renderObservationsList() {
        const listEl = document.getElementById("observationsList");

        if (observations.length === 0) {
          listEl.innerHTML =
            "<p>No observations yet. Create your first one!</p>";
          return;
        }

        listEl.innerHTML = observations
          .map(
            (obs) => `
          <div class="observation-card" onclick="viewObservation('${obs.id}')">
            <div class="observation-header">
              <div>
                <h3 class="observation-title">
                  ${obs.description || `${obs.label} observation`}
                </h3>
                <div class="observation-meta">
                  ${new Date(obs.startTime).toLocaleString()}
                  ${
                    obs.endTime
                      ? " - " + new Date(obs.endTime).toLocaleString()
                      : " (ongoing)"
                  }
                </div>
              </div>
              <div>
                <span class="badge badge-${obs.label}">${obs.label}</span>
                <span class="badge badge-${obs.status}">${obs.status}</span>
              </div>
            </div>
          </div>
        `
          )
          .join("");
      }

      // View observation detail
      async function viewObservation(id) {
        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${id}`,
            { method: "GET" }
          );

          if (!response.ok) throw new Error("Failed to load observation");

          currentObservation = await response.json();

          // Load notes
          await loadNotes(id);

          // Render detail view (but NOT the video yet)
          renderObservationDetail();

          // Show detail section
          document.getElementById("observationDetail").classList.add("active");
          document
            .getElementById("observationDetail")
            .scrollIntoView({ behavior: "smooth" });

          // NOW initialize the video player after the container is visible
          // Use requestAnimationFrame to ensure layout has completed
          requestAnimationFrame(() => {
            renderVideoPlayer();
          });
        } catch (error) {
          console.error("Error viewing observation:", error);
          alert("Failed to load observation details");
        }
      }

      // Render observation detail
      function renderObservationDetail() {
        const obs = currentObservation;

        document.getElementById("detailTitle").textContent =
          obs.description || `${obs.label} observation`;
        document.getElementById("detailMeta").innerHTML = `
          <span class="badge badge-${obs.label}">${obs.label}</span>
          <span class="badge badge-${obs.status}">${obs.status}</span>
          <span>${new Date(obs.startTime).toLocaleString()}</span>
          ${
            obs.endTime
              ? "<span> - " + new Date(obs.endTime).toLocaleString() + "</span>"
              : ""
          }
        `;

        // Update toggle status button
        const toggleBtn = document.getElementById("toggleStatusBtn");
        toggleBtn.textContent =
          obs.status === "active" ? "Mark Complete" : "Reopen";
        toggleBtn.className =
          obs.status === "active"
            ? "btn btn-primary btn-sm"
            : "btn btn-secondary btn-sm";

        // Render notes (video will be rendered separately after container is visible)
        renderNotes();
      }

      function renderVideoPlayer() {
        const playerEl = document.getElementById("videoPlayer");

        if (!currentObservation.recordingRef) {
          playerEl.innerHTML =
            '<div class="no-video-message">No video recording attached yet.</div>';
          videoElement = null;
          return;
        }

        const videoUrl = `https://${
          currentObservation.recordingRef.storageAccount || "devstoreaccount1"
        }.blob.core.windows.net/${currentObservation.recordingRef.container}/${
          currentObservation.recordingRef.blobName
        }`;

        // Reuse the same video element if it already exists
        let v = document.getElementById("videoEl");
        if (!v) {
          playerEl.innerHTML = "";
          v = document.createElement("video");
          v.id = "videoEl";
          v.controls = true;
          v.preload = "metadata";
          v.playsInline = true; // harmless on desktop, helpful on mobile
          v.crossOrigin = "anonymous";
          playerEl.appendChild(v);
        }

        // Hard reset the element before swapping sources
        v.pause();
        v.removeAttribute("src");
        v.load();

        // Set the URL directly (no <source> tag)
        v.src = videoUrl;

        // Force the browser to (re)initialize media pipeline
        v.load();

        // Keep your global ref
        videoElement = v;

        // Debug
        v.addEventListener(
          "loadedmetadata",
          () => {
            console.log("currentSrc:", v.currentSrc);
            console.log("duration:", v.duration);

            const ranges = [];
            for (let i = 0; i < v.seekable.length; i++) {
              ranges.push([v.seekable.start(i), v.seekable.end(i)]);
            }
            console.log("seekable.length after loadedmetadata:", v.seekable.length);
            console.log("seekable ranges:", ranges);

            // Test range request
            fetch(v.currentSrc, { headers: { Range: "bytes=0-1" } })
              .then((r) => {
                console.log("status", r.status);
                console.log("Content-Range", r.headers.get("content-range"));
                return r.arrayBuffer();
              })
              .then((b) => console.log("bytes", b.byteLength))
              .catch(console.error);
          },
          { once: true }
        );

        v.addEventListener(
          "canplay",
          () => {
            console.log("seekable.length after canplay:", v.seekable.length);
            const ranges = [];
            for (let i = 0; i < v.seekable.length; i++) {
              ranges.push([v.seekable.start(i), v.seekable.end(i)]);
            }
            console.log("seekable ranges after canplay:", ranges);
          },
          { once: true }
        );

        v.addEventListener(
          "error",
          () => {
            console.log("video error:", v.error);
          },
          { once: true }
        );
      }

      // Load notes for observation
      async function loadNotes(observationId) {
        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${observationId}/notes`,
            { method: "GET" }
          );

          if (!response.ok) throw new Error("Failed to load notes");

          notes = await response.json();
        } catch (error) {
          console.error("Error loading notes:", error);
          notes = [];
        }
      }

      // Render notes list
      function renderNotes() {
        const listEl = document.getElementById("notesList");

        if (notes.length === 0) {
          listEl.innerHTML = "<p>No notes yet.</p>";
          return;
        }

        listEl.innerHTML = notes
          .map((note) => {
            const hasTimestamp =
              note.offsetSeconds !== null && note.offsetSeconds !== undefined;

            return `
            <div class="note-card ${hasTimestamp ? "clickable" : ""}" ${
              hasTimestamp ? `onclick="seekToNote('${note.id}')"` : ""
            }>
              <div class="note-header">
                ${
                  hasTimestamp
                    ? `<span class="note-timestamp">${formatTime(
                        note.offsetSeconds
                      )}</span>`
                    : "<span>General Note</span>"
                }
                <div class="note-actions">
                  <button class="btn btn-danger btn-sm" onclick="handleDeleteNote(event, '${
                    note.id
                  }')">Delete</button>
                </div>
              </div>
              <p class="note-text">${escapeHtml(note.text)}</p>
            </div>
          `;
          })
          .join("");
      }

      // Seek video to note timestamp
      function seekToNote(noteId) {
        const note = notes.find((n) => n.id === noteId);
        if (!note || !videoElement || note.offsetSeconds === null) return;

        const recordingStartOffset =
          currentObservation.recordingRef?.recordingStartOffsetSeconds || 0;
        const seekTime = Math.max(0, note.offsetSeconds - recordingStartOffset);

        videoElement.currentTime = seekTime;
        videoElement.play();
      }

      // Use current video time for note
      function useCurrentVideoTime() {
        if (!videoElement) return;

        const recordingStartOffset =
          currentObservation.recordingRef?.recordingStartOffsetSeconds || 0;
        const offsetSeconds = Math.floor(
          videoElement.currentTime + recordingStartOffset
        );

        document.getElementById("noteOffset").value = offsetSeconds;
      }

      // Handle create observation
      async function handleCreateObservation(e) {
        e.preventDefault();

        const label = document.getElementById("observationLabel").value;
        const description = document.getElementById(
          "observationDescription"
        ).value;

        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/CreateObservation`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                label,
                description,
                startTime: new Date().toISOString(),
                status: "active",
              }),
            }
          );

          if (!response.ok) throw new Error("Failed to create observation");

          const newObs = await response.json();
          observations.unshift(newObs);

          // Reset form and hide
          document.getElementById("createObservationForm").reset();
          document
            .getElementById("newObservationForm")
            .classList.remove("active");

          // Reload list and view new observation
          renderObservationsList();
          viewObservation(newObs.id);
        } catch (error) {
          console.error("Error creating observation:", error);
          alert("Failed to create observation");
        }
      }

      // Show recording form
      function showRecordingForm() {
        document.getElementById("recordingForm").classList.add("active");

        // Pre-fill with existing values if available
        if (currentObservation.recordingRef) {
          document.getElementById("containerName").value =
            currentObservation.recordingRef.container;
          document.getElementById("blobName").value =
            currentObservation.recordingRef.blobName;
          document.getElementById("offsetSeconds").value =
            currentObservation.recordingRef.recordingStartOffsetSeconds || 0;
        }
      }

      // Hide recording form
      function hideRecordingForm() {
        document.getElementById("recordingForm").classList.remove("active");
        document.getElementById("attachRecordingForm").reset();
      }

      // Handle attach recording
      async function handleAttachRecording(e) {
        e.preventDefault();

        const container = document.getElementById("containerName").value;
        const blobName = document.getElementById("blobName").value;
        const offsetSeconds =
          parseInt(document.getElementById("offsetSeconds").value) || 0;

        try {
          const updatedObs = {
            ...currentObservation,
            recordingRef: {
              provider: "azure_blob",
              container,
              blobName,
              contentType: "video/mp4",
              recordingStartOffsetSeconds: offsetSeconds,
            },
          };

          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${currentObservation.id}`,
            {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(updatedObs),
            }
          );

          if (!response.ok) throw new Error("Failed to attach recording");

          currentObservation = await response.json();

          // Hide form and refresh view
          hideRecordingForm();
          renderObservationDetail();
        } catch (error) {
          console.error("Error attaching recording:", error);
          alert("Failed to attach recording");
        }
      }

      // Handle delete observation
      async function handleDeleteObservation() {
        if (
          !confirm(
            "Are you sure you want to delete this observation? This will also delete all associated notes."
          )
        ) {
          return;
        }

        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${currentObservation.id}`,
            { method: "DELETE" }
          );

          if (!response.ok) throw new Error("Failed to delete observation");

          // Remove from list and close detail
          observations = observations.filter(
            (o) => o.id !== currentObservation.id
          );
          renderObservationsList();
          closeDetail();
        } catch (error) {
          console.error("Error deleting observation:", error);
          alert("Failed to delete observation");
        }
      }

      // Handle toggle status
      async function handleToggleStatus() {
        try {
          const newStatus =
            currentObservation.status === "active" ? "completed" : "active";
          const updatedObs = {
            ...currentObservation,
            status: newStatus,
            endTime:
              newStatus === "completed" ? new Date().toISOString() : null,
          };

          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${currentObservation.id}`,
            {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(updatedObs),
            }
          );

          if (!response.ok) throw new Error("Failed to update status");

          currentObservation = await response.json();

          // Update in list
          const index = observations.findIndex(
            (o) => o.id === currentObservation.id
          );
          if (index !== -1) observations[index] = currentObservation;

          // Refresh views
          renderObservationsList();
          renderObservationDetail();
        } catch (error) {
          console.error("Error updating status:", error);
          alert("Failed to update observation status");
        }
      }

      // Handle add note
      async function handleAddNote(e) {
        e.preventDefault();

        const text = document.getElementById("noteText").value;
        const offsetInput = document.getElementById("noteOffset").value;
        const offsetSeconds = offsetInput ? parseInt(offsetInput) : null;

        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${currentObservation.id}/notes`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                text,
                offsetSeconds,
              }),
            }
          );

          if (!response.ok) throw new Error("Failed to add note");

          const newNote = await response.json();
          notes.push(newNote);
          notes.sort(
            (a, b) => (a.offsetSeconds || 999999) - (b.offsetSeconds || 999999)
          );

          // Reset form and refresh
          document.getElementById("addNoteForm").reset();
          renderNotes();
        } catch (error) {
          console.error("Error adding note:", error);
          alert("Failed to add note");
        }
      }

      // Handle delete note
      async function handleDeleteNote(event, noteId) {
        event.stopPropagation();

        if (!confirm("Delete this note?")) return;

        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${currentObservation.id}/notes/${noteId}`,
            { method: "DELETE" }
          );

          if (!response.ok) throw new Error("Failed to delete note");

          notes = notes.filter((n) => n.id !== noteId);
          renderNotes();
        } catch (error) {
          console.error("Error deleting note:", error);
          alert("Failed to delete note");
        }
      }

      // Close detail view
      function closeDetail() {
        document.getElementById("observationDetail").classList.remove("active");
        currentObservation = null;
        notes = [];
        videoElement = null;
      }

      // Utility: Format time in seconds to MM:SS
      function formatTime(seconds) {
        if (seconds === null || seconds === undefined) return "";
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, "0")}`;
      }

      // Utility: Escape HTML
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }
    </script>
  </body>
</html>
