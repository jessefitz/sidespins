---
layout: default
title: Lineup Explorer
---

<div id="lineup-explorer" class="lineup-explorer">
    <header class="explorer-header">
        <h1>{{ page.title }}</h1>
        <p class="description">
            Experiment with different player combinations for any match and see how they stack up against the APA 23-point skill cap. 
            Perfect for captains planning lineups or fans exploring what-if scenarios.
        </p>
    </header>

    <div id="loading" class="loading-state">
        <div class="spinner"></div>
        <p>Loading match data...</p>
    </div>

    <div id="error-message" class="error-state" style="display: none;">
        <p>Error loading data. Please try again later.</p>
    </div>

    <div id="main-content" class="main-content" style="display: none;">
        <!-- Match Selector -->
        <div class="match-selector">
            <label for="match-select">
                <strong>Select Match:</strong>
            </label>
            <select id="match-select" class="match-dropdown">
                <option value="">Choose a match...</option>
            </select>
        </div>

        <!-- Start State Toggle -->
        <div class="start-state-toggle" id="start-state-container" style="display: none;">
            <fieldset>
                <legend>Start with:</legend>
                <label>
                    <input type="radio" name="start-state" value="empty">
                    <span>Start empty</span>
                </label>
                <label id="captain-lineup-option" style="display: none;">
                    <input type="radio" name="start-state" value="captain" checked>
                    <span>Start from captain lineup</span>
                </label>
            </fieldset>
        </div>

        <!-- Info Badge -->
        <div class="info-badge">
            <div class="info-icon">ℹ️</div>
            <div class="info-text">
                <strong>23-Point Rule:</strong> APA 9-ball teams cannot exceed a combined skill level of 23 points in their lineup.
            </div>
        </div>

        <!-- Main Lineup Builder -->
        <div class="lineup-container">
            <!-- Lineup Slots -->
            <div class="lineup-section">
                <h3>Lineup Slots</h3>
                <div class="slots-container" id="slots-container">
                    <div class="slot-card" data-slot="1">
                        <div class="slot-header">
                            <span class="slot-number">1</span>
                        </div>
                        <div class="slot-content empty">
                            <div class="empty-state">
                                <p>Drop a player or click '+' to add</p>
                                <button class="add-btn" data-slot="1">+</button>
                            </div>
                        </div>
                    </div>
                    <div class="slot-card" data-slot="2">
                        <div class="slot-header">
                            <span class="slot-number">2</span>
                        </div>
                        <div class="slot-content empty">
                            <div class="empty-state">
                                <p>Drop a player or click '+' to add</p>
                                <button class="add-btn" data-slot="2">+</button>
                            </div>
                        </div>
                    </div>
                    <div class="slot-card" data-slot="3">
                        <div class="slot-header">
                            <span class="slot-number">3</span>
                        </div>
                        <div class="slot-content empty">
                            <div class="empty-state">
                                <p>Drop a player or click '+' to add</p>
                                <button class="add-btn" data-slot="3">+</button>
                            </div>
                        </div>
                    </div>
                    <div class="slot-card" data-slot="4">
                        <div class="slot-header">
                            <span class="slot-number">4</span>
                        </div>
                        <div class="slot-content empty">
                            <div class="empty-state">
                                <p>Drop a player or click '+' to add</p>
                                <button class="add-btn" data-slot="4">+</button>
                            </div>
                        </div>
                    </div>
                    <div class="slot-card" data-slot="5">
                        <div class="slot-header">
                            <span class="slot-number">5</span>
                        </div>
                        <div class="slot-content empty">
                            <div class="empty-state">
                                <p>Drop a player or click '+' to add</p>
                                <button class="add-btn" data-slot="5">+</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bench Panel -->
            <div class="bench-section">
                <div class="bench-header">
                    <h3>Available Players</h3>
                    
                    <!-- Filters -->
                    <div class="bench-filters">
                        <div class="filter-group">
                            <label for="skill-filter">Filter by Skill:</label>
                            <select id="skill-filter">
                                <option value="">All</option>
                                <option value="2">SL 2</option>
                                <option value="3">SL 3</option>
                                <option value="4">SL 4</option>
                                <option value="5">SL 5</option>
                                <option value="6">SL 6</option>
                                <option value="7">SL 7</option>
                            </select>
                        </div>
                        
                        <div class="sort-group">
                            <label for="sort-select">Sort by:</label>
                            <select id="sort-select">
                                <option value="skill-asc">Skill (Low to High)</option>
                                <option value="skill-desc">Skill (High to Low)</option>
                                <option value="name-asc">Name (A-Z)</option>
                                <option value="name-desc">Name (Z-A)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="bench-players" id="bench-players">
                    <div class="no-match-selected">
                        Select a match to see available players
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Live Cap Meter (Sticky Footer) -->
<div class="cap-meter-container" id="cap-meter" style="display: none;">
    <div class="cap-meter">
        <div class="total-display">
            <span class="total-label">Total SL:</span>
            <span class="total-value" id="total-value">0</span>
            <span class="cap-limit">/ 23</span>
        </div>
        <div class="meter-bar">
            <div class="meter-fill" id="meter-fill"></div>
        </div>
        <div class="status-text" id="status-text">23 remaining</div>
        <div class="quick-actions">
            <button class="clear-btn" id="clear-lineup">Clear All</button>
        </div>
    </div>
</div>

<!-- Player Selection Modal -->
<div class="modal-overlay" id="player-modal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Select Player for Slot <span id="modal-slot-number"></span></h3>
            <button class="modal-close" id="modal-close">×</button>
        </div>
        <div class="modal-body">
            <div class="modal-players" id="modal-players">
                <!-- Players will be populated here -->
            </div>
        </div>
    </div>
</div>

<style>
.lineup-explorer {
    max-width: 1200px;
    margin: 0 auto;
    padding: 1rem;
}

.explorer-header {
    text-align: center;
    margin-bottom: 2rem;
}

.description {
    color: #666;
    font-size: 1.1rem;
    max-width: 600px;
    margin: 0 auto;
    line-height: 1.5;
}

.loading-state, .error-state {
    text-align: center;
    padding: 3rem 1rem;
}

.spinner {
    border: 3px solid #f3f3f3;
    border-top: 3px solid #007cba;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
    margin: 0 auto 1rem;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.match-selector {
    margin-bottom: 1.5rem;
}

.match-dropdown {
    width: 100%;
    max-width: 400px;
    padding: 0.5rem;
    font-size: 1rem;
    border: 2px solid #ddd;
    border-radius: 4px;
    margin-top: 0.5rem;
}

.start-state-toggle {
    margin-bottom: 1.5rem;
}

.start-state-toggle fieldset {
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 1rem;
    margin: 0;
}

.start-state-toggle legend {
    font-weight: bold;
    padding: 0 0.5rem;
}

.start-state-toggle label {
    display: block;
    margin: 0.5rem 0;
    cursor: pointer;
}

.start-state-toggle input[type="radio"] {
    margin-right: 0.5rem;
}

.info-badge {
    display: flex;
    align-items: center;
    background: #e3f2fd;
    border: 1px solid #90caf9;
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 2rem;
}

.info-icon {
    font-size: 1.5rem;
    margin-right: 1rem;
}

.lineup-container {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 2rem;
    margin-bottom: 100px; /* Space for sticky footer */
}

@media (max-width: 768px) {
    .lineup-container {
        grid-template-columns: 1fr;
        gap: 1rem;
    }
}

.lineup-section h3, .bench-section h3 {
    margin-bottom: 1rem;
}

.slots-container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.slot-card {
    border: 2px dashed #ddd;
    border-radius: 8px;
    background: #fafafa;
    transition: all 0.3s ease;
    min-height: 80px;
}

.slot-card.filled {
    border-style: solid;
    border-color: #007cba;
    background: white;
}

.slot-card.drag-over {
    border-color: #4caf50;
    background: #f0f8f0;
}

.slot-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.5rem 1rem;
    background: #f0f0f0;
    border-radius: 6px 6px 0 0;
}

.slot-number {
    font-weight: bold;
    color: #007cba;
}

.slot-content {
    padding: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 60px;
}

.slot-content.empty {
    color: #999;
    text-align: center;
}

.empty-state p {
    margin: 0 0 0.5rem 0;
    font-size: 0.9rem;
}

.add-btn {
    background: #007cba;
    color: white;
    border: none;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    font-size: 1.2rem;
    cursor: pointer;
    transition: background-color 0.2s;
}

.add-btn:hover {
    background: #005a87;
}

.player-card {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.5rem;
    background: white;
    border-radius: 4px;
    margin-bottom: 0.5rem;
}

.player-info {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.player-name {
    font-weight: 500;
}

.skill-badge {
    background: #007cba;
    color: white;
    padding: 0.2rem 0.5rem;
    border-radius: 12px;
    font-size: 0.8rem;
    font-weight: bold;
}

.player-actions {
    display: flex;
    gap: 0.5rem;
}

.change-btn, .remove-btn {
    padding: 0.2rem 0.5rem;
    border: none;
    border-radius: 4px;
    font-size: 0.8rem;
    cursor: pointer;
    transition: background-color 0.2s;
}

.change-btn {
    background: #ffc107;
    color: #333;
}

.change-btn:hover {
    background: #e6ac00;
}

.remove-btn {
    background: #dc3545;
    color: white;
}

.remove-btn:hover {
    background: #c82333;
}

.bench-section {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1rem;
    height: fit-content;
}

.bench-header {
    margin-bottom: 1rem;
}

.bench-filters {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.filter-group, .sort-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.filter-group label, .sort-group label {
    font-size: 0.9rem;
    font-weight: 500;
    min-width: 70px;
}

.filter-group select, .sort-group select {
    flex: 1;
    padding: 0.3rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 0.9rem;
}

.bench-players {
    max-height: 400px;
    overflow-y: auto;
}

.player-pill {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem;
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    margin-bottom: 0.5rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.player-pill:hover {
    background: #f0f8ff;
    border-color: #007cba;
}

.player-pill.dragging {
    opacity: 0.5;
}

.player-pill-info {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.drag-handle {
    color: #999;
    cursor: grab;
    font-size: 1.2rem;
}

.drag-handle:active {
    cursor: grabbing;
}

.player-pill .add-btn {
    width: 24px;
    height: 24px;
    font-size: 1rem;
}

.no-match-selected {
    text-align: center;
    color: #999;
    font-style: italic;
    padding: 2rem;
}

.cap-meter-container {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: white;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
    z-index: 100;
}

.cap-meter {
    max-width: 1200px;
    margin: 0 auto;
    padding: 1rem;
    display: flex;
    align-items: center;
    gap: 1rem;
}

.total-display {
    font-size: 1.2rem;
    font-weight: bold;
    white-space: nowrap;
}

.total-value {
    font-size: 1.5rem;
    color: #007cba;
}

.total-value.over-cap {
    color: #dc3545;
    animation: pulse 1s ease-in-out;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

.meter-bar {
    flex: 1;
    height: 20px;
    background: #e9ecef;
    border-radius: 10px;
    overflow: hidden;
    position: relative;
}

.meter-fill {
    height: 100%;
    background: #28a745;
    border-radius: 10px;
    transition: all 0.3s ease;
    width: 0%;
}

.meter-fill.at-cap {
    background: #ffc107;
}

.meter-fill.over-cap {
    background: #dc3545;
}

.status-text {
    font-weight: 500;
    min-width: 100px;
    text-align: center;
}

.status-text.over-cap {
    color: #dc3545;
    font-weight: bold;
}

.clear-btn {
    background: #6c757d;
    color: white;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.clear-btn:hover {
    background: #5a6268;
}

/* Modal Styles */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.modal-content {
    background: white;
    border-radius: 8px;
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    overflow: hidden;
}

.modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem;
    border-bottom: 1px solid #ddd;
}

.modal-header h3 {
    margin: 0;
}

.modal-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0.25rem;
    line-height: 1;
}

.modal-body {
    padding: 1rem;
    max-height: 60vh;
    overflow-y: auto;
}

.modal-players .player-pill {
    cursor: pointer;
}

.modal-players .player-pill:hover {
    background: #e3f2fd;
}

/* Mobile Responsive */
@media (max-width: 768px) {
    .cap-meter {
        flex-direction: column;
        gap: 0.5rem;
        padding: 0.75rem;
    }
    
    .total-display {
        order: 1;
    }
    
    .meter-bar {
        order: 2;
        height: 15px;
    }
    
    .status-text {
        order: 3;
        min-width: auto;
    }
    
    .clear-btn {
        order: 4;
    }
    
    .bench-section {
        order: -1;
    }
    
    .bench-filters {
        flex-direction: row;
        flex-wrap: wrap;
    }
    
    .filter-group, .sort-group {
        flex: 1;
        min-width: 140px;
    }
}
</style>

<script>
class LineupExplorer {
    constructor() {
        this.apiBaseUrl = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
            ? 'http://localhost:7071/api' 
            : 'https://sidespinsapi.azurewebsites.net/api';
        
        // Default division - should be configurable later
        this.divisionId = 'div_nottingham_wed_9b_311';
        
        this.state = {
            matchId: null,
            slots: [null, null, null, null, null], // 5 slots, indexed 0-4
            bench: [],
            totalSkill: 0,
            ui: {
                filters: { sl: null },
                sort: { key: 'skill', dir: 'asc' }
            }
        };
        
        this.init();
    }

    async init() {
        try {
            await this.loadMatches();
            this.bindEvents();
            
            // Check for match ID in query string AFTER everything is set up
            const urlParams = new URLSearchParams(window.location.search);
            const matchIdParam = urlParams.get('matchId');
            
            if (matchIdParam) {
                await this.selectMatch(matchIdParam);
            }
            
            this.showMainContent();
        } catch (error) {
            console.error('Error initializing lineup explorer:', error);
            this.showError();
        }
    }

    async loadMatches() {
        const response = await fetch(`${this.apiBaseUrl}/public/matches?divisionId=${this.divisionId}`);
        if (!response.ok) throw new Error('Failed to load matches');
        
        const matches = await response.json();
        this.populateMatchSelect(matches);
    }

    populateMatchSelect(matches) {
        const select = document.getElementById('match-select');
        select.innerHTML = '<option value="">Choose a match...</option>';
        
        // Sort matches by date (most recent first)
        const sortedMatches = matches.sort((a, b) => new Date(b.scheduledAt) - new Date(a.scheduledAt));
        
        sortedMatches.forEach(match => {
            const option = document.createElement('option');
            option.value = match.id;
            
            const date = new Date(match.scheduledAt).toLocaleDateString();
            const teams = [];
            if (match.homeTeamId) teams.push('Home');
            if (match.awayTeamId) teams.push('Away');
            
            option.textContent = `Week ${match.week} - ${date} (${teams.join(' vs ')})`;
            option.dataset.hasLineup = match.hasLineup;
            
            select.appendChild(option);
        });
    }

    async selectMatch(matchId) {
        if (!matchId) return;
        
        try {
            console.log('Selecting match:', matchId);
            this.state.matchId = matchId;
            
            // Make sure the select element is updated
            const selectElement = document.getElementById('match-select');
            selectElement.value = matchId;
            
            // Fetch full match data to get lineup info
            const matchResponse = await fetch(`${this.apiBaseUrl}/public/matches?divisionId=${this.divisionId}`);
            if (matchResponse.ok) {
                const matches = await matchResponse.json();
                this.currentMatch = matches.find(m => m.id === matchId);
                console.log('Found match data:', this.currentMatch);
            }
            
            // Show/hide captain lineup option
            const selectedOption = document.querySelector(`#match-select option[value="${matchId}"]`);
            const hasLineup = selectedOption?.dataset.hasLineup === 'true';
            const captainOption = document.getElementById('captain-lineup-option');
            const container = document.getElementById('start-state-container');
            
            console.log('Has lineup:', hasLineup, 'Selected option:', selectedOption);
            
            if (hasLineup) {
                captainOption.style.display = 'block';
                container.style.display = 'block';
                // Default to captain lineup when available
                document.querySelector('input[value="captain"]').checked = true;
            } else {
                captainOption.style.display = 'none';
                container.style.display = 'block';
                // Only use empty as default when no captain lineup is available
                document.querySelector('input[value="empty"]').checked = true;
            }

            // Load roster for this match
            await this.loadMatchRoster(matchId);
            
            // Show the cap meter
            document.getElementById('cap-meter').style.display = 'block';
            
            // Reset lineup
            this.clearLineup();
            
            // If captain lineup is selected as default, load it automatically
            if (hasLineup && document.querySelector('input[value="captain"]').checked) {
                this.loadCaptainLineup();
            }
            
            console.log('Match selection complete');
            
        } catch (error) {
            console.error('Error selecting match:', error);
            alert('Error loading match data. Please try again.');
        }
    }

    async loadMatchRoster(matchId) {
        console.log('Loading roster for match:', matchId);
        const response = await fetch(`${this.apiBaseUrl}/public/matches/${matchId}/roster?divisionId=${this.divisionId}`);
        if (!response.ok) throw new Error('Failed to load match roster');
        
        const roster = await response.json();
        console.log('Loaded roster:', roster);
        this.state.bench = roster;
        this.renderBenchPlayers();
    }

    loadCaptainLineup() {
        if (!this.currentMatch || !this.currentMatch.lineupPlan) {
            console.log('No captain lineup data available');
            return;
        }

        // Clear current lineup first
        this.clearLineup();

        const lineupPlan = this.currentMatch.lineupPlan;
        
        // Determine which lineup to use (home or away)
        // For now, we'll use home lineup if available, otherwise away
        let lineup = lineupPlan.home;
        if (!lineup || lineup.length === 0) {
            lineup = lineupPlan.away;
        }

        if (!lineup || lineup.length === 0) {
            console.log('No lineup data found in captain lineup');
            return;
        }

        // Load the lineup into slots (excluding alternates)
        const activeLineup = lineup.filter(player => !player.isAlternate).slice(0, 5);
        
        activeLineup.forEach((lineupPlayer, index) => {
            // Find the player in our roster
            const player = this.state.bench.find(p => p.playerId === lineupPlayer.playerId);
            if (player && index < 5) {
                this.state.slots[index] = player.playerId;
            }
        });

        // Re-render the lineup and bench
        this.renderSlots();
        this.renderBenchPlayers();
        this.updateCapMeter();
    }

    bindEvents() {
        // Match selection
        document.getElementById('match-select').addEventListener('change', (e) => {
            this.selectMatch(e.target.value);
        });

        // Filters and sorting
        document.getElementById('skill-filter').addEventListener('change', (e) => {
            this.state.ui.filters.sl = e.target.value ? parseInt(e.target.value) : null;
            this.renderBenchPlayers();
        });

        document.getElementById('sort-select').addEventListener('change', (e) => {
            const [key, dir] = e.target.value.split('-');
            this.state.ui.sort = { key, dir };
            this.renderBenchPlayers();
        });

        // Clear button
        document.getElementById('clear-lineup').addEventListener('click', () => {
            this.clearLineup();
        });

        // Start state radio buttons
        document.querySelectorAll('input[name="start-state"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.value === 'captain' && e.target.checked) {
                    this.loadCaptainLineup();
                } else if (e.target.value === 'empty' && e.target.checked) {
                    this.clearLineup();
                }
            });
        });

        // Slot add buttons
        document.querySelectorAll('.add-btn').forEach(btn => {
            if (btn.dataset.slot) {
                btn.addEventListener('click', (e) => {
                    const slot = parseInt(e.target.dataset.slot) - 1; // Convert to 0-based index
                    this.showPlayerModal(slot);
                });
            }
        });

        // Modal events
        document.getElementById('modal-close').addEventListener('click', () => {
            this.hidePlayerModal();
        });

        document.getElementById('player-modal').addEventListener('click', (e) => {
            if (e.target.id === 'player-modal') {
                this.hidePlayerModal();
            }
        });

        // Drag and drop
        this.initDragAndDrop();
    }

    initDragAndDrop() {
        // Make slots droppable
        document.querySelectorAll('.slot-card').forEach(slot => {
            slot.addEventListener('dragover', this.handleDragOver.bind(this));
            slot.addEventListener('drop', this.handleDrop.bind(this));
            slot.addEventListener('dragleave', this.handleDragLeave.bind(this));
        });
    }

    handleDragOver(e) {
        e.preventDefault();
        e.currentTarget.classList.add('drag-over');
    }

    handleDragLeave(e) {
        e.currentTarget.classList.remove('drag-over');
    }

    handleDrop(e) {
        e.preventDefault();
        e.currentTarget.classList.remove('drag-over');
        
        const playerId = e.dataTransfer.getData('text/plain');
        const slot = parseInt(e.currentTarget.dataset.slot) - 1; // Convert to 0-based
        
        if (playerId) {
            this.assignPlayerToSlot(playerId, slot);
        }
    }

    showPlayerModal(slotIndex) {
        if (!this.state.matchId) {
            alert('Please select a match first.');
            return;
        }

        this.currentModalSlot = slotIndex;
        document.getElementById('modal-slot-number').textContent = slotIndex + 1;
        
        // Populate available players
        const availablePlayers = this.getAvailablePlayers();
        this.renderModalPlayers(availablePlayers);
        
        document.getElementById('player-modal').style.display = 'flex';
    }

    hidePlayerModal() {
        document.getElementById('player-modal').style.display = 'none';
        this.currentModalSlot = null;
    }

    renderModalPlayers(players) {
        const container = document.getElementById('modal-players');
        container.innerHTML = '';
        
        if (players.length === 0) {
            container.innerHTML = '<p class="no-players">No available players</p>';
            return;
        }

        players.forEach(player => {
            const pill = document.createElement('div');
            pill.className = 'player-pill';
            pill.innerHTML = `
                <div class="player-pill-info">
                    <span class="player-name">${player.name}</span>
                    <span class="skill-badge">SL ${player.skill}</span>
                </div>
            `;
            
            pill.addEventListener('click', () => {
                this.assignPlayerToSlot(player.playerId, this.currentModalSlot);
                this.hidePlayerModal();
            });
            
            container.appendChild(pill);
        });
    }

    assignPlayerToSlot(playerId, slotIndex) {
        // Check if player is already assigned
        if (this.state.slots.includes(playerId)) {
            this.showToast('Player is already in the lineup');
            return;
        }

        // Remove from current slot if reassigning
        const currentSlotIndex = this.state.slots.indexOf(playerId);
        if (currentSlotIndex !== -1) {
            this.state.slots[currentSlotIndex] = null;
        }

        // Assign to new slot
        this.state.slots[slotIndex] = playerId;
        
        this.renderSlots();
        this.renderBenchPlayers();
        this.updateCapMeter();
    }

    removePlayerFromSlot(slotIndex) {
        this.state.slots[slotIndex] = null;
        this.renderSlots();
        this.renderBenchPlayers();
        this.updateCapMeter();
    }

    getAvailablePlayers() {
        return this.state.bench.filter(player => !this.state.slots.includes(player.playerId));
    }

    getFilteredAndSortedPlayers() {
        let players = this.getAvailablePlayers();
        
        // Apply skill filter
        if (this.state.ui.filters.sl !== null) {
            players = players.filter(p => p.skill === this.state.ui.filters.sl);
        }

        // Apply sorting
        const { key, dir } = this.state.ui.sort;
        players.sort((a, b) => {
            let valueA, valueB;
            
            if (key === 'skill') {
                valueA = a.skill;
                valueB = b.skill;
            } else {
                valueA = a.name.toLowerCase();
                valueB = b.name.toLowerCase();
            }

            if (dir === 'desc') {
                return valueB > valueA ? 1 : -1;
            } else {
                return valueA > valueB ? 1 : -1;
            }
        });

        return players;
    }

    renderBenchPlayers() {
        const container = document.getElementById('bench-players');
        
        if (!this.state.matchId) {
            container.innerHTML = '<div class="no-match-selected">Select a match to see available players</div>';
            return;
        }

        const players = this.getFilteredAndSortedPlayers();
        container.innerHTML = '';

        if (players.length === 0) {
            container.innerHTML = '<div class="no-match-selected">No available players match the current filter</div>';
            return;
        }

        players.forEach(player => {
            const pill = document.createElement('div');
            pill.className = 'player-pill';
            pill.draggable = true;
            pill.innerHTML = `
                <div class="player-pill-info">
                    <span class="drag-handle">⋮⋮</span>
                    <span class="player-name">${player.name}</span>
                    <span class="skill-badge">SL ${player.skill}</span>
                </div>
                <button class="add-btn" data-player-id="${player.playerId}">+</button>
            `;

            // Add drag events
            pill.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', player.playerId);
                pill.classList.add('dragging');
            });

            pill.addEventListener('dragend', () => {
                pill.classList.remove('dragging');
            });

            // Add click event for add button
            const addBtn = pill.querySelector('.add-btn');
            addBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                
                // Find first empty slot
                const emptySlotIndex = this.state.slots.findIndex(slot => slot === null);
                if (emptySlotIndex !== -1) {
                    this.assignPlayerToSlot(player.playerId, emptySlotIndex);
                } else {
                    // Show modal to choose slot
                    this.showSlotSelectionModal(player.playerId);
                }
            });

            container.appendChild(pill);
        });
    }

    showSlotSelectionModal(playerId) {
        // For now, just show an alert. Could be enhanced with a proper modal
        const slotChoice = prompt('All slots are filled. Which slot would you like to replace? (1-5)');
        if (slotChoice && slotChoice >= 1 && slotChoice <= 5) {
            this.assignPlayerToSlot(playerId, parseInt(slotChoice) - 1);
        }
    }

    renderSlots() {
        this.state.slots.forEach((playerId, index) => {
            const slotElement = document.querySelector(`[data-slot="${index + 1}"]`);
            const content = slotElement.querySelector('.slot-content');
            
            if (playerId) {
                const player = this.state.bench.find(p => p.playerId === playerId);
                if (player) {
                    slotElement.classList.add('filled');
                    content.className = 'slot-content filled';
                    content.innerHTML = `
                        <div class="player-card">
                            <div class="player-info">
                                <span class="player-name">${player.name}</span>
                                <span class="skill-badge">SL ${player.skill}</span>
                            </div>
                            <div class="player-actions">
                                <button class="change-btn" onclick="lineupExplorer.showPlayerModal(${index})">Change</button>
                                <button class="remove-btn" onclick="lineupExplorer.removePlayerFromSlot(${index})">×</button>
                            </div>
                        </div>
                    `;
                }
            } else {
                slotElement.classList.remove('filled');
                content.className = 'slot-content empty';
                content.innerHTML = `
                    <div class="empty-state">
                        <p>Drop a player or click '+' to add</p>
                        <button class="add-btn" data-slot="${index + 1}" onclick="lineupExplorer.showPlayerModal(${index})">+</button>
                    </div>
                `;
            }
        });
    }

    updateCapMeter() {
        // Calculate total skill
        this.state.totalSkill = this.state.slots.reduce((total, playerId) => {
            if (playerId) {
                const player = this.state.bench.find(p => p.playerId === playerId);
                return total + (player ? player.skill : 0);
            }
            return total;
        }, 0);

        // Update display
        const totalValue = document.getElementById('total-value');
        const meterFill = document.getElementById('meter-fill');
        const statusText = document.getElementById('status-text');
        
        totalValue.textContent = this.state.totalSkill;
        
        // Calculate percentage for meter
        const percentage = Math.min((this.state.totalSkill / 23) * 100, 100);
        meterFill.style.width = `${percentage}%`;
        
        // Update colors and status
        if (this.state.totalSkill > 23) {
            totalValue.classList.add('over-cap');
            meterFill.className = 'meter-fill over-cap';
            statusText.textContent = `Over cap by ${this.state.totalSkill - 23}`;
            statusText.className = 'status-text over-cap';
        } else if (this.state.totalSkill === 23) {
            totalValue.classList.remove('over-cap');
            meterFill.className = 'meter-fill at-cap';
            statusText.textContent = 'At cap';
            statusText.className = 'status-text';
        } else {
            totalValue.classList.remove('over-cap');
            meterFill.className = 'meter-fill';
            statusText.textContent = `${23 - this.state.totalSkill} remaining`;
            statusText.className = 'status-text';
        }
    }

    clearLineup() {
        this.state.slots = [null, null, null, null, null];
        this.renderSlots();
        this.renderBenchPlayers();
        this.updateCapMeter();
    }

    showToast(message) {
        // Simple toast implementation
        const toast = document.createElement('div');
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 1rem;
            border-radius: 4px;
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.3s;
        `;
        toast.textContent = message;
        document.body.appendChild(toast);
        
        setTimeout(() => toast.style.opacity = '1', 10);
        setTimeout(() => {
            toast.style.opacity = '0';
            setTimeout(() => document.body.removeChild(toast), 300);
        }, 3000);
    }

    showMainContent() {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('main-content').style.display = 'block';
    }

    showError() {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('error-message').style.display = 'block';
    }
}

// Initialize when page loads
let lineupExplorer;
document.addEventListener('DOMContentLoaded', () => {
    lineupExplorer = new LineupExplorer();
});
</script>
