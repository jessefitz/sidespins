---
layout: default
title: Observations - SideSpins
---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Observations - SideSpins</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f5f5f5;
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem 1rem;
      }

      .header-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 2rem;
      }

      .header-left {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .btn-back {
        background: transparent;
        color: #666;
        border: 1px solid #e1e5e9;
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
      }

      .btn-back:hover {
        background: #f8f9fa;
        border-color: #007cba;
        color: #007cba;
      }

      h1 {
        margin: 0;
        color: #333;
      }

      .btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 6px;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.2s;
        text-decoration: none;
        display: inline-block;
      }

      .btn-primary {
        background: #007cba;
        color: white;
      }

      .btn-primary:hover {
        background: #005a87;
      }

      .btn-secondary {
        background: #6c757d;
        color: white;
      }

      .btn-secondary:hover {
        background: #5a6268;
      }

      .btn-danger {
        background: #dc3545;
        color: white;
      }

      .btn-danger:hover {
        background: #c82333;
      }

      .btn-sm {
        padding: 0.5rem 1rem;
        font-size: 0.875rem;
      }

      /* Observations List */
      .observations-list {
        background: white;
        border-radius: 8px;
        padding: 1.5rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 2rem;
      }

      .observation-card {
        border: 1px solid #e1e5e9;
        border-radius: 6px;
        padding: 1rem;
        margin-bottom: 1rem;
        cursor: pointer;
        transition: all 0.2s;
      }

      .observation-card:hover {
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      .observation-card.active {
        border-color: #007cba;
        background: #f8f9fa;
      }

      .observation-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 0.5rem;
      }

      .observation-title {
        font-size: 1.125rem;
        font-weight: 600;
        margin: 0;
      }

      .observation-meta {
        color: #666;
        font-size: 0.875rem;
      }

      .badge {
        display: inline-block;
        padding: 0.25rem 0.75rem;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
      }

      .badge-practice {
        background: #e3f2fd;
        color: #1976d2;
      }

      .badge-match {
        background: #fff3e0;
        color: #f57c00;
      }

      .badge-active {
        background: #e8f5e9;
        color: #388e3c;
      }

      .badge-completed {
        background: #f3e5f5;
        color: #7b1fa2;
      }

      /* Observation Detail View */
      .observation-detail {
        background: white;
        border-radius: 8px;
        padding: 1.5rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: none;
      }

      .observation-detail.active {
        display: block;
      }

      .detail-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid #e1e5e9;
      }

      .detail-actions {
        display: flex;
        gap: 0.5rem;
      }

      /* Video Player */
      .video-section {
        margin-bottom: 2rem;
      }

      video {
        width: 100%;
        max-width: 100%;
        border-radius: 8px;
        background: #000;
      }

      .no-video-message {
        text-align: center;
        padding: 3rem;
        background: #f8f9fa;
        border-radius: 8px;
        color: #666;
      }

      /* Recording Form */
      .recording-form {
        background: #f8f9fa;
        padding: 1.5rem;
        border-radius: 6px;
        margin-top: 1rem;
        display: none;
      }

      .recording-form.active {
        display: block;
      }

      .form-group {
        margin-bottom: 1rem;
      }

      .form-group label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 600;
        color: #333;
      }

      .form-control {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid #e1e5e9;
        border-radius: 6px;
        font-size: 1rem;
      }

      .form-control:focus {
        outline: none;
        border-color: #007cba;
      }

      /* Notes Section */
      .notes-section {
        margin-top: 2rem;
      }

      .notes-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
      }

      .notes-list {
        max-height: 400px;
        overflow-y: auto;
      }

      .note-card {
        border: 1px solid #e1e5e9;
        border-radius: 6px;
        padding: 1rem;
        margin-bottom: 0.75rem;
        transition: all 0.2s;
      }

      .note-card:hover {
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .note-card.clickable {
        cursor: pointer;
      }

      .note-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
      }

      .note-timestamp {
        font-weight: 600;
        color: #007cba;
        cursor: pointer;
      }

      .note-actions {
        display: flex;
        gap: 0.5rem;
      }

      .note-text {
        color: #333;
        margin: 0;
      }

      .note-form {
        background: #f8f9fa;
        padding: 1.5rem;
        border-radius: 6px;
        margin-bottom: 1rem;
      }

      .form-row {
        display: flex;
        gap: 1rem;
      }

      .form-row .form-group {
        flex: 1;
      }

      /* New Observation Form */
      .new-observation-form {
        background: white;
        border-radius: 8px;
        padding: 1.5rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        display: none;
        margin-bottom: 2rem;
      }

      .new-observation-form.active {
        display: block;
      }

      .timer {
        font-size: 1.5rem;
        font-weight: 600;
        color: #007cba;
        margin: 1rem 0;
        text-align: center;
      }

      /* Loading & Error States */
      .loading {
        text-align: center;
        padding: 2rem;
        color: #666;
      }

      /* Blob Picker Styles */
      .blob-picker {
        border: 1px solid #e1e5e9;
        border-radius: 6px;
        max-height: 300px;
        overflow-y: auto;
        background: white;
      }

      .blob-item {
        padding: 0.75rem 1rem;
        border-bottom: 1px solid #e1e5e9;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      .blob-item:last-child {
        border-bottom: none;
      }

      .blob-item:hover {
        background: #f8f9fa;
      }

      .blob-item.selected {
        background: #e3f2fd;
        border-color: #007cba;
      }

      .blob-checkbox {
        width: 18px;
        height: 18px;
        cursor: pointer;
      }

      .blob-info {
        flex: 1;
      }

      .blob-name {
        font-weight: 500;
        color: #333;
        word-break: break-all;
      }

      .blob-meta {
        font-size: 0.875rem;
        color: #666;
        margin-top: 0.25rem;
      }

      .blob-picker-actions {
        margin-top: 1rem;
        display: flex;
        gap: 0.5rem;
      }

      .selected-count {
        color: #007cba;
        font-weight: 600;
        padding: 0.5rem;
      }

      .search-box {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid #e1e5e9;
        border-radius: 6px;
        margin-bottom: 0.75rem;
        font-size: 1rem;
      }

      .search-box:focus {
        outline: none;
        border-color: #007cba;
      }

      .error-message {
        background: #fee;
        border: 1px solid #fcc;
        color: #c33;
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 1rem;
      }

      .success-message {
        background: #efe;
        border: 1px solid #cfc;
        color: #3c3;
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 1rem;
      }

      /* Modal Styles */
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        justify-content: center;
        align-items: center;
        overflow-y: auto;
      }

      .modal.active {
        display: flex;
      }

      .modal-content {
        background: white;
        border-radius: 12px;
        padding: 2rem;
        max-width: 700px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
        margin: 2rem auto;
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid #e1e5e9;
      }

      .modal-header h3 {
        margin: 0;
      }

      .modal-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: #666;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .modal-close:hover {
        color: #333;
      }

      .video-part-dropdown {
        margin-bottom: 1rem;
      }

      .video-part-dropdown label {
        font-weight: 600;
        margin-right: 0.5rem;
      }

      .video-part-dropdown select {
        padding: 0.5rem;
        border: 1px solid #e1e5e9;
        border-radius: 6px;
        font-size: 1rem;
      }

      /* Responsive */
      @media (max-width: 768px) {
        .header-actions {
          flex-direction: column;
          gap: 1rem;
          align-items: flex-start;
        }

        .form-row {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <div class="header-actions">
        <div class="header-left">
          <a href="/app.html" class="btn btn-back btn-sm">‚Üê Dashboard</a>
          <h1>üìπ Observations</h1>
        </div>
        <button class="btn btn-primary" id="newObservationBtn">
          + New Observation
        </button>
      </div>

      <!-- New Observation Form -->
      <div class="new-observation-form" id="newObservationForm">
        <h2>Create New Observation</h2>
        <form id="createObservationForm">
          <div class="form-group">
            <label for="observationLabel">Type</label>
            <select id="observationLabel" class="form-control" required>
              <option value="practice">Practice</option>
              <option value="match">Match</option>
            </select>
          </div>
          <div class="form-group">
            <label for="observationDescription">Description</label>
            <textarea
              id="observationDescription"
              class="form-control"
              rows="3"
              placeholder="Optional description..."
            ></textarea>
          </div>
          <div class="form-row">
            <button type="submit" class="btn btn-primary">
              Start Observation
            </button>
            <button type="button" class="btn btn-secondary" id="cancelNewBtn">
              Cancel
            </button>
          </div>
        </form>
      </div>

      <!-- Observations List -->
      <div class="observations-list">
        <h2>Recent Observations</h2>
        <div id="observationsList" class="loading">Loading observations...</div>
      </div>

      <!-- Observation Detail -->
      <div class="observation-detail" id="observationDetail">
        <div class="detail-header">
          <div>
            <h2 id="detailTitle">Observation Details</h2>
            <div id="detailMeta" class="observation-meta"></div>
          </div>
          <div class="detail-actions">
            <button class="btn btn-secondary btn-sm" id="attachRecordingBtn">
              Attach Recording
            </button>
            <button class="btn btn-sm" id="toggleStatusBtn">
              Mark Complete
            </button>
            <button class="btn btn-danger btn-sm" id="deleteObservationBtn">
              Delete
            </button>
            <button class="btn btn-secondary btn-sm" id="closeDetailBtn">
              Close
            </button>
          </div>
        </div>

        <!-- Video Player -->
        <div class="video-section">
          <div id="videoPlayer"></div>
        </div>

        <!-- Notes Section -->
        <div class="notes-section">
          <div class="notes-header">
            <h3>Notes</h3>
            <button class="btn btn-primary btn-sm" id="addNoteBtn">
              + Add Note
            </button>
          </div>

          <!-- Notes List -->
          <div class="notes-list" id="notesList">
            <p class="loading">No notes yet.</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Note Modal -->
    <div id="noteModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Add Note</h3>
          <button class="modal-close" onclick="hideNoteModal()">&times;</button>
        </div>
        <form id="noteModalForm">
          <div class="form-group">
            <label for="noteTypeSelect">Note Type</label>
            <select id="noteTypeSelect" class="form-control" required>
              <option value="moment">Moment in Time</option>
              <option value="general">General Observation</option>
            </select>
          </div>
          <div class="form-group" id="timestampGroup">
            <label for="timestampSelect">Timestamp</label>
            <select id="timestampSelect" class="form-control">
              <option value="now">Now</option>
              <option value="30">Now Minus 30 Seconds</option>
              <option value="60">Now Minus 1 Minute</option>
              <option value="120">Now Minus 2 Minutes</option>
              <option value="180">Now Minus 3 Minutes</option>
              <option value="240">Now Minus 4 Minutes</option>
              <option value="300">Now Minus 5 Minutes</option>
            </select>
          </div>
          <div class="form-group">
            <label for="noteModalText">Note Text</label>
            <textarea
              id="noteModalText"
              class="form-control"
              rows="3"
              placeholder="Enter your note..."
              required
            ></textarea>
          </div>
          <div style="display: flex; gap: 0.5rem; margin-top: 1rem">
            <button type="submit" class="btn btn-primary">Add Note</button>
            <button
              type="button"
              class="btn btn-secondary"
              onclick="hideNoteModal()"
            >
              Cancel
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Recording Modal -->
    <div id="recordingModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Manage Video Recordings</h3>
          <button class="modal-close" onclick="hideRecordingModal()">
            &times;
          </button>
        </div>

        <!-- List of existing parts -->
        <div id="modalRecordingPartsList" class="mb-3"></div>

        <!-- Add new part form -->
        <form id="modalAttachRecordingForm">
          <h4>Add Recording Parts</h4>

          <div class="form-group">
            <label for="modalContainerName">Container Name</label>
            <input
              type="text"
              id="modalContainerName"
              class="form-control"
              value="videos"
              required
            />
            <button
              type="button"
              class="btn btn-secondary btn-sm"
              id="modalLoadBlobsBtn"
              style="margin-top: 0.5rem"
            >
              Load Videos
            </button>
          </div>

          <!-- Blob Picker -->
          <div id="modalBlobPickerContainer" style="display: none">
            <div class="form-group">
              <label>Select Video Files (multiple selection supported)</label>
              <input
                type="text"
                id="modalBlobSearch"
                class="search-box"
                placeholder="Search videos..."
              />
              <div id="modalBlobPicker" class="blob-picker">
                <div class="loading">
                  Click "Load Videos" to see available files
                </div>
              </div>
              <div class="blob-picker-actions">
                <span id="modalSelectedCount" class="selected-count"
                  >0 videos selected</span
                >
                <button
                  type="button"
                  class="btn btn-sm btn-secondary"
                  id="modalSelectAllBtn"
                >
                  Select All
                </button>
                <button
                  type="button"
                  class="btn btn-sm btn-secondary"
                  id="modalClearSelectionBtn"
                >
                  Clear Selection
                </button>
              </div>
            </div>
          </div>

          <div style="display: flex; gap: 0.5rem; margin-top: 1rem">
            <button
              type="submit"
              class="btn btn-primary"
              id="modalAddPartsBtn"
              disabled
            >
              Add Selected Videos
            </button>
            <button
              type="button"
              class="btn btn-secondary"
              onclick="hideRecordingModal()"
            >
              Close
            </button>
          </div>
        </form>
      </div>
    </div>

    <script src="/assets/auth.js"></script>
    <script>
      const authManager = new AuthManager();
      let observations = [];
      let currentObservation = null;
      let notes = [];
      let videoElement = null;
      let activeTimer = null;
      let availableBlobs = [];
      let selectedBlobs = new Set();

      // Initialize
      document.addEventListener("DOMContentLoaded", async () => {
        // Check authentication
        const isAuthenticated = await authManager.requireAuth(
          "/login-new.html?redirect=" +
            encodeURIComponent(window.location.pathname)
        );
        if (!isAuthenticated) return;

        // Load observations
        await loadObservations();

        // Event listeners
        document
          .getElementById("newObservationBtn")
          .addEventListener("click", () => {
            document
              .getElementById("newObservationForm")
              .classList.add("active");
          });

        document
          .getElementById("cancelNewBtn")
          .addEventListener("click", () => {
            document
              .getElementById("newObservationForm")
              .classList.remove("active");
            document.getElementById("createObservationForm").reset();
          });

        document
          .getElementById("createObservationForm")
          .addEventListener("submit", handleCreateObservation);
        document
          .getElementById("attachRecordingBtn")
          .addEventListener("click", showRecordingModal);
        document
          .getElementById("modalAttachRecordingForm")
          .addEventListener("submit", handleAttachRecordingModal);
        document
          .getElementById("modalLoadBlobsBtn")
          .addEventListener("click", loadBlobsModal);
        document
          .getElementById("modalSelectAllBtn")
          .addEventListener("click", selectAllBlobsModal);
        document
          .getElementById("modalClearSelectionBtn")
          .addEventListener("click", clearSelectionModal);
        document
          .getElementById("modalBlobSearch")
          .addEventListener("input", filterBlobsModal);
        document
          .getElementById("closeDetailBtn")
          .addEventListener("click", closeDetail);
        document
          .getElementById("deleteObservationBtn")
          .addEventListener("click", handleDeleteObservation);
        document
          .getElementById("toggleStatusBtn")
          .addEventListener("click", handleToggleStatus);
        document
          .getElementById("addNoteBtn")
          .addEventListener("click", showNoteModal);
        document
          .getElementById("noteModalForm")
          .addEventListener("submit", handleAddNoteModal);
        document
          .getElementById("noteTypeSelect")
          .addEventListener("change", handleNoteTypeChange);

        // Modal background click handlers
        document.getElementById("noteModal").addEventListener("click", (e) => {
          if (e.target.id === "noteModal") {
            hideNoteModal();
          }
        });

        document
          .getElementById("recordingModal")
          .addEventListener("click", (e) => {
            if (e.target.id === "recordingModal") {
              hideRecordingModal();
            }
          });
      });

      // Load all observations
      async function loadObservations() {
        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/GetObservations`,
            { method: "GET" }
          );

          if (!response.ok) throw new Error("Failed to load observations");

          observations = await response.json();
          renderObservationsList();
        } catch (error) {
          console.error("Error loading observations:", error);
          document.getElementById("observationsList").innerHTML =
            '<div class="error-message">Failed to load observations.</div>';
        }
      }

      // Render observations list
      function renderObservationsList() {
        const listEl = document.getElementById("observationsList");

        if (observations.length === 0) {
          listEl.innerHTML =
            "<p>No observations yet. Create your first one!</p>";
          return;
        }

        listEl.innerHTML = observations
          .map(
            (obs) => `
          <div class="observation-card" onclick="viewObservation('${obs.id}')">
            <div class="observation-header">
              <div>
                <h3 class="observation-title">
                  ${obs.description || `${obs.label} observation`}
                </h3>
                <div class="observation-meta">
                  ${new Date(obs.startTime).toLocaleString()}
                  ${
                    obs.endTime
                      ? " - " + new Date(obs.endTime).toLocaleString()
                      : " (ongoing)"
                  }
                </div>
              </div>
              <div>
                <span class="badge badge-${obs.label}">${obs.label}</span>
                <span class="badge badge-${obs.status}">${obs.status}</span>
              </div>
            </div>
          </div>
        `
          )
          .join("");
      }

      // View observation detail
      async function viewObservation(id) {
        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${id}`,
            { method: "GET" }
          );

          if (!response.ok) throw new Error("Failed to load observation");

          currentObservation = await response.json();

          // Load notes
          await loadNotes(id);

          // Render detail view (but NOT the video yet)
          renderObservationDetail();

          // Show detail section
          document.getElementById("observationDetail").classList.add("active");
          document
            .getElementById("observationDetail")
            .scrollIntoView({ behavior: "smooth" });

          // NOW initialize the video player after the container is visible
          // Use requestAnimationFrame to ensure layout has completed
          requestAnimationFrame(() => {
            renderVideoPlayer();
          });
        } catch (error) {
          console.error("Error viewing observation:", error);
          alert("Failed to load observation details");
        }
      }

      // Render observation detail
      function renderObservationDetail() {
        const obs = currentObservation;

        document.getElementById("detailTitle").textContent =
          obs.description || `${obs.label} observation`;
        document.getElementById("detailMeta").innerHTML = `
          <span class="badge badge-${obs.label}">${obs.label}</span>
          <span class="badge badge-${obs.status}">${obs.status}</span>
          <span>${new Date(obs.startTime).toLocaleString()}</span>
          ${
            obs.endTime
              ? "<span> - " + new Date(obs.endTime).toLocaleString() + "</span>"
              : ""
          }
        `;

        // Show/hide Attach Recording button based on observation status
        const attachBtn = document.getElementById("attachRecordingBtn");
        if (obs.status === "completed") {
          attachBtn.style.display = "inline-block";
        } else {
          attachBtn.style.display = "none";
        }

        // Update toggle status button
        const toggleBtn = document.getElementById("toggleStatusBtn");
        toggleBtn.textContent =
          obs.status === "active" ? "Mark Complete" : "Reopen";
        toggleBtn.className =
          obs.status === "active"
            ? "btn btn-primary btn-sm"
            : "btn btn-secondary btn-sm";

        // Render notes (video will be rendered separately after container is visible)
        renderNotes();
      }

      // Global state for multi-part video
      let currentVideoPart = null;
      let sortedParts = [];

      function renderVideoPlayer() {
        const playerEl = document.getElementById("videoPlayer");

        if (
          !currentObservation.recordingParts ||
          currentObservation.recordingParts.length === 0
        ) {
          playerEl.innerHTML =
            '<div class="no-video-message">No video recording attached yet.</div>';
          videoElement = null;
          currentVideoPart = null;
          sortedParts = [];
          return;
        }

        // Sort parts by startOffsetSeconds
        sortedParts = [...currentObservation.recordingParts].sort(
          (a, b) => a.startOffsetSeconds - b.startOffsetSeconds
        );

        // Build HTML with dropdown if multiple parts
        let html = "";

        // Debug logging
        console.log(
          "Recording parts:",
          sortedParts.map((p) => ({
            blobName: p.blobName,
            startOffsetSeconds: p.startOffsetSeconds,
            durationSeconds: p.durationSeconds,
          }))
        );

        if (sortedParts.length > 1) {
          html += '<div class="video-part-dropdown">';
          html += "<label>Select Part:</label>";
          html += '<select id="partSelector" onchange="handlePartSelection()">';
          sortedParts.forEach((part, index) => {
            // Show observation timeline offsets (where this part starts and ends in the observation)
            const startOffset = formatTime(part.startOffsetSeconds);
            let endOffset;

            if (index < sortedParts.length - 1) {
              // End offset is where the next part starts
              endOffset = formatTime(sortedParts[index + 1].startOffsetSeconds);
            } else {
              // Last part - show as "End"
              endOffset = "End";
            }

            console.log(
              `Part ${index + 1}: ${startOffset} - ${endOffset} (raw: ${
                part.startOffsetSeconds
              } - ${
                index < sortedParts.length - 1
                  ? sortedParts[index + 1].startOffsetSeconds
                  : "end"
              })`
            );

            html += `<option value="${index}">Part ${
              index + 1
            } (${startOffset} - ${endOffset})</option>`;
          });
          html += "</select>";
          html += "</div>";
        }

        html += '<div id="videoContainer"></div>';
        playerEl.innerHTML = html;

        // Load first part
        loadVideoPart(sortedParts[0], 0);
      }

      function handlePartSelection() {
        const selector = document.getElementById("partSelector");
        const selectedIndex = parseInt(selector.value);
        const selectedPart = sortedParts[selectedIndex];

        if (selectedPart) {
          loadVideoPart(selectedPart, selectedIndex, { autoplay: false });
        }
      }

      function loadVideoPart(
        part,
        partIndex,
        { autoplay = false, seekTo = null } = {}
      ) {
        const containerEl = document.getElementById("videoContainer");

        // Use Azure Front Door CDN for video playback
        const videoUrl = `https://storage-cdn-d0egdudcfacwdeh7.z03.azurefd.net/${part.container}/${part.blobName}`;

        if (!videoElement) {
          // Create video element on first load
          videoElement = document.createElement("video");
          videoElement.id = "videoEl";
          videoElement.controls = true;
          videoElement.preload = "metadata";
          videoElement.playsInline = true;
          videoElement.crossOrigin = "anonymous";

          containerEl.innerHTML = "";
          containerEl.appendChild(videoElement);

          // Auto-transition to next part when current part ends
          videoElement.addEventListener("ended", handleVideoEnded);
        }

        // Update source
        videoElement.src = videoUrl;
        currentVideoPart = part;
        updatePartIndicator(partIndex);

        // Update dropdown selection if it exists
        const selector = document.getElementById("partSelector");
        if (selector) {
          selector.value = partIndex;
        }

        // Wait for metadata before seeking or playing
        const onReady = () => {
          if (typeof seekTo === "number") {
            videoElement.currentTime = seekTo;
          }

          if (autoplay) {
            videoElement.play().catch(() => {});
          }

          videoElement.removeEventListener("loadedmetadata", onReady);
        };

        videoElement.addEventListener("loadedmetadata", onReady);
        videoElement.load();
      }

      function handleVideoEnded() {
        if (!currentVideoPart || !sortedParts.length) return;

        const currentIndex = sortedParts.findIndex(
          (p) => p.partNumber === currentVideoPart.partNumber
        );

        if (currentIndex >= 0 && currentIndex < sortedParts.length - 1) {
          // Auto-transition to next part
          const nextPart = sortedParts[currentIndex + 1];
          loadVideoPart(nextPart, currentIndex + 1, { autoplay: true });
        }
      }

      function updatePartIndicator(partIndex) {
        // Add visual indicator of current part (if multiple parts exist)
        if (!sortedParts || sortedParts.length <= 1) return;

        const containerEl = document.getElementById("videoContainer");
        let indicator = document.getElementById("partIndicator");

        if (!indicator) {
          indicator = document.createElement("div");
          indicator.id = "partIndicator";
          indicator.style.cssText =
            "position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 4px; font-size: 12px; z-index: 10;";
          containerEl.style.position = "relative";
          containerEl.appendChild(indicator);
        }

        indicator.textContent = `Part ${partIndex + 1} of ${
          sortedParts.length
        }`;
      }

      // Load notes for observation
      async function loadNotes(observationId) {
        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${observationId}/notes`,
            { method: "GET" }
          );

          if (!response.ok) throw new Error("Failed to load notes");

          notes = await response.json();
        } catch (error) {
          console.error("Error loading notes:", error);
          notes = [];
        }
      }

      // Render notes list
      function renderNotes() {
        const listEl = document.getElementById("notesList");

        if (notes.length === 0) {
          listEl.innerHTML = "<p>No notes yet.</p>";
          return;
        }

        listEl.innerHTML = notes
          .map((note) => {
            const hasTimestamp =
              note.offsetSeconds !== null && note.offsetSeconds !== undefined;

            // Build author display
            const authorInfo = note.createdByName
              ? `<span style="color: #666; font-size: 0.875rem;">By ${escapeHtml(
                  note.createdByName
                )}</span>`
              : "";

            return `
            <div class="note-card ${hasTimestamp ? "clickable" : ""}" ${
              hasTimestamp ? `onclick="seekToNote('${note.id}')"` : ""
            }>
              <div class="note-header">
                <div>
                  ${
                    hasTimestamp
                      ? `<span class="note-timestamp">${formatTime(
                          note.offsetSeconds
                        )}</span>`
                      : "<span>General Note</span>"
                  }
                  ${authorInfo ? ` ‚Ä¢ ${authorInfo}` : ""}
                </div>
                <div class="note-actions">
                  <button class="btn btn-danger btn-sm" onclick="handleDeleteNote(event, '${
                    note.id
                  }')">Delete</button>
                </div>
              </div>
              <p class="note-text">${escapeHtml(note.text)}</p>
            </div>
          `;
          })
          .join("");
      }

      // Seek video to note timestamp
      function seekToNote(noteId) {
        const note = notes.find((n) => n.id === noteId);
        if (!note || note.offsetSeconds === null) return;

        // Find which part contains this timestamp
        const result = findPartForTimestamp(note.offsetSeconds);
        if (!result) {
          console.warn(
            `No video part found for timestamp ${note.offsetSeconds}`
          );
          return;
        }

        // Calculate seek time within the video part
        const seekTime = note.offsetSeconds - result.part.startOffsetSeconds;

        console.log(
          `Seeking to note: offset=${note.offsetSeconds}, part=${
            result.index + 1
          }, seekTime=${seekTime}`
        );

        // Check if we need to switch to a different part
        if (
          !currentVideoPart ||
          currentVideoPart.partNumber !== result.part.partNumber
        ) {
          // Switch to the correct part and seek
          loadVideoPart(result.part, result.index, {
            autoplay: true,
            seekTo: Math.max(0, seekTime),
          });
        } else {
          // Same part, just seek
          videoElement.currentTime = Math.max(0, seekTime);
          videoElement.play();
        }
      }

      function findPartForTimestamp(offsetSeconds) {
        if (!sortedParts || sortedParts.length === 0) return null;

        for (let i = 0; i < sortedParts.length; i++) {
          const part = sortedParts[i];
          const nextPart = sortedParts[i + 1];

          if (!nextPart) {
            // Last part handles everything from its start onward
            if (offsetSeconds >= part.startOffsetSeconds) {
              return { part, index: i };
            }
          } else {
            // This part handles from its start to next part's start
            if (
              offsetSeconds >= part.startOffsetSeconds &&
              offsetSeconds < nextPart.startOffsetSeconds
            ) {
              return { part, index: i };
            }
          }
        }

        return null;
      }

      // Use current video time for note
      function useCurrentVideoTime() {
        if (!videoElement || !currentVideoPart) return;

        const offsetSeconds = Math.floor(
          videoElement.currentTime + currentVideoPart.startOffsetSeconds
        );

        document.getElementById("noteOffset").value = offsetSeconds;
      }

      // Handle create observation
      async function handleCreateObservation(e) {
        e.preventDefault();

        const label = document.getElementById("observationLabel").value;
        const description = document.getElementById(
          "observationDescription"
        ).value;

        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/CreateObservation`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                label,
                description,
                startTime: new Date().toISOString(),
                status: "active",
              }),
            }
          );

          if (!response.ok) throw new Error("Failed to create observation");

          const newObs = await response.json();
          observations.unshift(newObs);

          // Reset form and hide
          document.getElementById("createObservationForm").reset();
          document
            .getElementById("newObservationForm")
            .classList.remove("active");

          // Reload list and view new observation
          renderObservationsList();
          viewObservation(newObs.id);
        } catch (error) {
          console.error("Error creating observation:", error);
          alert("Failed to create observation");
        }
      }

      // Parse filename format: YYYY_MMDD_HHMMSS_SEQ[_custom].EXT
      // Example: 2018_0102_025808_002_faststart.MP4
      function parseRecordingFilename(filename) {
        const pattern = /^(\d{4})_(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})_(\d{3})/;
        const match = filename.match(pattern);

        if (!match) return null;

        const [, year, month, day, hour, minute, second, seq] = match;

        return {
          timestamp: new Date(
            parseInt(year),
            parseInt(month) - 1, // JS months are 0-indexed
            parseInt(day),
            parseInt(hour),
            parseInt(minute),
            parseInt(second)
          ),
          sequenceNumber: parseInt(seq),
          year: parseInt(year),
          month: parseInt(month),
          day: parseInt(day),
          hour: parseInt(hour),
          minute: parseInt(minute),
          second: parseInt(second),
        };
      }

      // Show recording modal
      function showRecordingModal() {
        document.getElementById("recordingModal").classList.add("active");
        document.getElementById("modalContainerName").value = "videos";
        selectedBlobs.clear();
        availableBlobs = [];
        renderModalRecordingPartsList();
      }

      // Hide recording modal
      function hideRecordingModal() {
        document.getElementById("recordingModal").classList.remove("active");
        document.getElementById("modalAttachRecordingForm").reset();
        document.getElementById("modalBlobPickerContainer").style.display =
          "none";
        selectedBlobs.clear();
        availableBlobs = [];
      }

      // Render recording parts list in modal
      function renderModalRecordingPartsList() {
        const listEl = document.getElementById("modalRecordingPartsList");

        if (
          !currentObservation.recordingParts ||
          currentObservation.recordingParts.length === 0
        ) {
          listEl.innerHTML =
            "<p><em>No recording parts yet. Add one below.</em></p>";
          return;
        }

        const sortedParts = [...currentObservation.recordingParts].sort(
          (a, b) => a.startOffsetSeconds - b.startOffsetSeconds
        );

        listEl.innerHTML = `
          <h4>Current Parts</h4>
          <div class="parts-list">
            ${sortedParts
              .map((part, index) => {
                const parsed = parseRecordingFilename(part.blobName);
                const timestampInfo = parsed
                  ? `<span style="color: #28a745;">üìπ ${parsed.year}-${String(
                      parsed.month
                    ).padStart(2, "0")}-${String(parsed.day).padStart(
                      2,
                      "0"
                    )} ${String(parsed.hour).padStart(2, "0")}:${String(
                      parsed.minute
                    ).padStart(2, "0")}:${String(parsed.second).padStart(
                      2,
                      "0"
                    )}</span>`
                  : "";

                return `
              <div class="part-card" style="border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 4px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <div>
                    <strong>Part ${index + 1}</strong> ${timestampInfo}
                    <div style="font-size: 12px; color: #666;">
                      ${part.blobName}<br>
                      Start: ${formatTime(part.startOffsetSeconds)}
                      ${
                        part.durationSeconds
                          ? ` | Duration: ${formatTime(part.durationSeconds)}`
                          : ""
                      }
                    </div>
                  </div>
                  <button class="btn btn-danger btn-sm" onclick="handleDeleteRecordingPartModal(${index})">
                    Delete
                  </button>
                </div>
              </div>
            `;
              })
              .join("")}
          </div>
        `;
      }

      // Load available blobs in modal
      async function loadBlobsModal() {
        const container = document.getElementById("modalContainerName").value;
        const pickerEl = document.getElementById("modalBlobPicker");
        const pickerContainer = document.getElementById(
          "modalBlobPickerContainer"
        );

        pickerEl.innerHTML = '<div class="loading">Loading videos...</div>';
        pickerContainer.style.display = "block";

        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/blobs/list?container=${encodeURIComponent(
              container
            )}`,
            { method: "GET" }
          );

          if (!response.ok) throw new Error("Failed to load blobs");

          const data = await response.json();
          availableBlobs = data.blobs || [];

          renderBlobPickerModal();
        } catch (error) {
          console.error("Error loading blobs:", error);
          pickerEl.innerHTML =
            '<div class="error-message">Failed to load videos. Check container name.</div>';
        }
      }

      // Render blob picker in modal
      function renderBlobPickerModal(filteredBlobs = null) {
        const pickerEl = document.getElementById("modalBlobPicker");
        const blobs = filteredBlobs || availableBlobs;

        if (blobs.length === 0) {
          pickerEl.innerHTML =
            '<div class="loading">No video files found in this container.</div>';
          return;
        }

        pickerEl.innerHTML = blobs
          .map((blob) => {
            const isSelected = selectedBlobs.has(blob.name);
            const sizeMB = (blob.sizeBytes / 1024 / 1024).toFixed(2);
            const date = new Date(blob.lastModified).toLocaleString();

            return `
              <div class="blob-item ${
                isSelected ? "selected" : ""
              }" data-blob-name="${blob.name}">
                <input 
                  type="checkbox" 
                  class="blob-checkbox" 
                  ${isSelected ? "checked" : ""} 
                  onchange="toggleBlobSelectionModal('${blob.name}')"
                />
                <div class="blob-info">
                  <div class="blob-name">${blob.name}</div>
                  <div class="blob-meta">${sizeMB} MB ‚Ä¢ ${date}</div>
                </div>
              </div>
            `;
          })
          .join("");

        updateSelectedCountModal();
      }

      // Toggle blob selection in modal
      function toggleBlobSelectionModal(blobName) {
        if (selectedBlobs.has(blobName)) {
          selectedBlobs.delete(blobName);
        } else {
          selectedBlobs.add(blobName);
        }

        updateSelectedCountModal();
        updateAddButtonModal();

        // Update UI
        const blobItem = document.querySelector(
          `[data-blob-name="${blobName}"]`
        );
        if (blobItem) {
          blobItem.classList.toggle("selected");
        }
      }

      // Select all visible blobs in modal
      function selectAllBlobsModal() {
        const searchTerm = document
          .getElementById("modalBlobSearch")
          .value.toLowerCase();
        const visibleBlobs = searchTerm
          ? availableBlobs.filter((b) =>
              b.name.toLowerCase().includes(searchTerm)
            )
          : availableBlobs;

        visibleBlobs.forEach((blob) => selectedBlobs.add(blob.name));
        renderBlobPickerModal(searchTerm ? visibleBlobs : null);
      }

      // Clear all selections in modal
      function clearSelectionModal() {
        selectedBlobs.clear();
        renderBlobPickerModal();
      }

      // Filter blobs by search term in modal
      function filterBlobsModal() {
        const searchTerm = document
          .getElementById("modalBlobSearch")
          .value.toLowerCase();
        if (!searchTerm) {
          renderBlobPickerModal();
          return;
        }

        const filtered = availableBlobs.filter((blob) =>
          blob.name.toLowerCase().includes(searchTerm)
        );
        renderBlobPickerModal(filtered);
      }

      // Update selected count display in modal
      function updateSelectedCountModal() {
        document.getElementById("modalSelectedCount").textContent = `${
          selectedBlobs.size
        } video${selectedBlobs.size !== 1 ? "s" : ""} selected`;
      }

      // Update add button state in modal
      function updateAddButtonModal() {
        const addBtn = document.getElementById("modalAddPartsBtn");
        addBtn.disabled = selectedBlobs.size === 0;
      }

      // Handle attach recording from modal
      async function handleAttachRecordingModal(e) {
        e.preventDefault();

        const container = document.getElementById("modalContainerName").value;

        // Multi-select mode - process selected blobs
        if (selectedBlobs.size === 0) {
          alert("Please select at least one video file");
          return;
        }

        try {
          let newParts = [];

          // Convert selected blob names to array and sort
          const selectedBlobNames = Array.from(selectedBlobs).sort();

          // Parse each filename and create parts
          const parsedBlobs = selectedBlobNames.map((name) => ({
            name,
            parsed: parseRecordingFilename(name),
          }));

          // Sort by timestamp (earliest first)
          parsedBlobs.sort((a, b) => {
            if (!a.parsed || !b.parsed) return 0;
            return a.parsed.timestamp - b.parsed.timestamp;
          });

          // Calculate part numbers and offsets
          const existingParts = currentObservation.recordingParts || [];
          let nextPartNumber = 1;
          if (existingParts.length > 0) {
            nextPartNumber =
              Math.max(...existingParts.map((p) => p.partNumber)) + 1;
          }

          let cumulativeOffsetSeconds = 0;

          for (let i = 0; i < parsedBlobs.length; i++) {
            const { name, parsed } = parsedBlobs[i];
            let startOffsetSeconds = cumulativeOffsetSeconds;
            let durationSeconds = null;

            if (parsed) {
              // Calculate duration from timestamp difference to next video
              if (i < parsedBlobs.length - 1 && parsedBlobs[i + 1].parsed) {
                const currentTimestamp = parsed.timestamp;
                const nextTimestamp = parsedBlobs[i + 1].parsed.timestamp;
                durationSeconds = Math.floor(
                  (nextTimestamp - currentTimestamp) / 1000
                );

                // Update cumulative offset for next part
                cumulativeOffsetSeconds += durationSeconds;
              }
            }

            newParts.push({
              partNumber: parsed ? parsed.sequenceNumber : nextPartNumber + i,
              provider: "azure_blob",
              container,
              blobName: name,
              contentType: "video/mp4",
              startOffsetSeconds,
              durationSeconds,
            });
          }

          // Merge with existing parts
          const existingPartsCopy = currentObservation.recordingParts || [];
          const updatedParts = [...existingPartsCopy];

          // Add or replace parts
          for (const newPart of newParts) {
            const existingIndex = updatedParts.findIndex(
              (p) => p.partNumber === newPart.partNumber
            );
            if (existingIndex >= 0) {
              // Replace existing
              updatedParts[existingIndex] = newPart;
            } else {
              // Add new
              updatedParts.push(newPart);
            }
          }

          const updatedObs = {
            ...currentObservation,
            recordingParts: updatedParts,
          };

          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${currentObservation.id}`,
            {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(updatedObs),
            }
          );

          if (!response.ok) throw new Error("Failed to add recording parts");

          currentObservation = await response.json();

          // Reset and refresh
          selectedBlobs.clear();
          renderModalRecordingPartsList();

          // Refresh video player
          requestAnimationFrame(() => {
            renderVideoPlayer();
          });

          alert(
            `Successfully added ${newParts.length} recording part${
              newParts.length !== 1 ? "s" : ""
            }`
          );
        } catch (error) {
          console.error("Error adding recording parts:", error);
          alert("Failed to add recording parts");
        }
      }

      // Handle delete recording part from modal
      async function handleDeleteRecordingPartModal(partIndex) {
        const sortedParts = [...currentObservation.recordingParts].sort(
          (a, b) => a.startOffsetSeconds - b.startOffsetSeconds
        );
        const partToDelete = sortedParts[partIndex];

        if (!confirm(`Delete Part ${partIndex + 1}?`)) return;

        try {
          const updatedParts = currentObservation.recordingParts.filter(
            (p) => p.partNumber !== partToDelete.partNumber
          );

          const updatedObs = {
            ...currentObservation,
            recordingParts: updatedParts,
          };

          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${currentObservation.id}`,
            {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(updatedObs),
            }
          );

          if (!response.ok) throw new Error("Failed to delete recording part");

          currentObservation = await response.json();

          // Refresh list and video player
          renderModalRecordingPartsList();
          requestAnimationFrame(() => {
            renderVideoPlayer();
          });
        } catch (error) {
          console.error("Error deleting recording part:", error);
          alert("Failed to delete recording part");
        }
      }

      // Handle delete observation
      async function handleDeleteObservation() {
        if (
          !confirm(
            "Are you sure you want to delete this observation? This will also delete all associated notes."
          )
        ) {
          return;
        }

        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${currentObservation.id}`,
            { method: "DELETE" }
          );

          if (!response.ok) throw new Error("Failed to delete observation");

          // Remove from list and close detail
          observations = observations.filter(
            (o) => o.id !== currentObservation.id
          );
          renderObservationsList();
          closeDetail();
        } catch (error) {
          console.error("Error deleting observation:", error);
          alert("Failed to delete observation");
        }
      }

      // Handle toggle status
      async function handleToggleStatus() {
        try {
          const newStatus =
            currentObservation.status === "active" ? "completed" : "active";
          const updatedObs = {
            ...currentObservation,
            status: newStatus,
            endTime:
              newStatus === "completed" ? new Date().toISOString() : null,
          };

          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${currentObservation.id}`,
            {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(updatedObs),
            }
          );

          if (!response.ok) throw new Error("Failed to update status");

          currentObservation = await response.json();

          // Update in list
          const index = observations.findIndex(
            (o) => o.id === currentObservation.id
          );
          if (index !== -1) observations[index] = currentObservation;

          // Refresh views
          renderObservationsList();
          renderObservationDetail();
        } catch (error) {
          console.error("Error updating status:", error);
          alert("Failed to update observation status");
        }
      }

      // Handle delete note
      async function handleDeleteNote(event, noteId) {
        event.stopPropagation();

        if (!confirm("Delete this note?")) return;

        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${currentObservation.id}/notes/${noteId}`,
            { method: "DELETE" }
          );

          if (!response.ok) throw new Error("Failed to delete note");

          notes = notes.filter((n) => n.id !== noteId);
          renderNotes();
        } catch (error) {
          console.error("Error deleting note:", error);
          alert("Failed to delete note");
        }
      }

      // Close detail view
      function closeDetail() {
        document.getElementById("observationDetail").classList.remove("active");
        currentObservation = null;
        notes = [];
        videoElement = null;
      }

      // Show note modal
      function showNoteModal() {
        document.getElementById("noteModal").classList.add("active");
        document.getElementById("noteModalForm").reset();
        document.getElementById("timestampGroup").style.display = "block";
      }

      // Hide note modal
      function hideNoteModal() {
        document.getElementById("noteModal").classList.remove("active");
        document.getElementById("noteModalForm").reset();
      }

      // Handle note type change
      function handleNoteTypeChange() {
        const noteType = document.getElementById("noteTypeSelect").value;
        const timestampGroup = document.getElementById("timestampGroup");

        if (noteType === "general") {
          timestampGroup.style.display = "none";
        } else {
          timestampGroup.style.display = "block";
        }
      }

      // Handle add note from modal
      async function handleAddNoteModal(e) {
        e.preventDefault();

        const text = document.getElementById("noteModalText").value;
        const noteType = document.getElementById("noteTypeSelect").value;
        let offsetSeconds = null;

        if (noteType === "moment") {
          const timestampValue =
            document.getElementById("timestampSelect").value;

          if (timestampValue === "now") {
            // Use current video time if available
            if (videoElement && currentVideoPart) {
              offsetSeconds = Math.floor(
                videoElement.currentTime + currentVideoPart.startOffsetSeconds
              );
            } else {
              // No video, use observation elapsed time
              const obsStart = new Date(currentObservation.startTime);
              const now = new Date();
              offsetSeconds = Math.floor((now - obsStart) / 1000);
            }
          } else {
            // Calculate "now minus X seconds"
            const subtractSeconds = parseInt(timestampValue);
            if (videoElement && currentVideoPart) {
              offsetSeconds = Math.floor(
                videoElement.currentTime +
                  currentVideoPart.startOffsetSeconds -
                  subtractSeconds
              );
            } else {
              const obsStart = new Date(currentObservation.startTime);
              const now = new Date();
              offsetSeconds =
                Math.floor((now - obsStart) / 1000) - subtractSeconds;
            }
          }

          // Ensure offset is not negative
          offsetSeconds = Math.max(0, offsetSeconds);
        }

        try {
          const response = await authManager.makeAuthenticatedRequest(
            `${authManager.baseUrl}/observations/${currentObservation.id}/notes`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                text,
                offsetSeconds,
              }),
            }
          );

          if (!response.ok) throw new Error("Failed to add note");

          const newNote = await response.json();
          notes.push(newNote);
          notes.sort(
            (a, b) => (a.offsetSeconds || 999999) - (b.offsetSeconds || 999999)
          );

          // Close modal and refresh
          hideNoteModal();
          renderNotes();
        } catch (error) {
          console.error("Error adding note:", error);
          alert("Failed to add note");
        }
      }

      // Utility: Format time in seconds to MM:SS
      function formatTime(seconds) {
        if (seconds === null || seconds === undefined) return "";
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, "0")}`;
      }

      // Utility: Escape HTML
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }
    </script>
  </body>
</html>
